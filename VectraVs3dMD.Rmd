---
title: "VectraVs3dMD"
author: "Ciara Virgo & Julie White"
date: "December 5, 2018"
output: html_document
---

```{r}
setwd("C:/Users/Julie White/Box/PSU_KU_Collaboration/Vectra_vs_3dMD")
```

# Packages and Functions
```{r, echo=FALSE}
library(geomorph)
library(R.matlab)
library(plotly)
library(reshape2)
library(ggplot2)
library(data.table)
library(readr)
library(Morpho)
library(mixOmics)
library(dplyr)
library(ggpubr)
library(ggthemr)
library(tidyr)
library(gmodels)
library(foreach)
library(doParallel)
library(purr)
```

Plot1Face script
This script was written by Tomas Gonzalez-Zarzar and can be found at https://github.com/Arslan-Zaidi/Facial_masculinity_MHC/tree/master/Tutorial_visualizing_facial_heatmaps
```{r}
source('Plot1Face.R')
RefScan <- read.table("FacialTemplate_20171201.obj", sep = "\t", header = F, colClasses = c("character", rep("numeric", 3)))
RefScan_Facets <- as.matrix(RefScan[which(RefScan$V1 == "f"), 2:4])
RefScan_Vertices <- as.matrix(RefScan[which(RefScan$V1 == "v"), 2:4])

#Remove RefScan since we don't need it anymore
rm(RefScan)
```

Technical error of measurement function, extended to be useful for two or three measurements. Function can be found here: https://stackoverflow.com/questions/32041102/technical-error-of-measurement-tem-for-3-or-more-participants

Paper reference: Goto and Mascie-Taylor, JPA, 2007
```{r}
#TEM function
tem <- function(M) {
    nrows <- nrow(M)
    ncols <- ncol(M)
    sqrt(sum(apply(M,1,function(x) sum(x^2) - sum(x)^2/ncols))/(nrows*(ncols-1)))
}

#Rewrite the function for bootstrapping
tem.bootstrap <- function(splits) {
  nrows <- nrow(analysis(splits))
  ncols <- ncol(analysis(splits))
  return(sqrt(sum(apply(analysis(splits),1,function(x) sum(x^2) - sum(x)^2/ncols))/(nrows*(ncols-1))))
}

#rTEM function
rTEM <- function(M) {tem(M)/mean(as.matrix(M))*100}

#R function 
tem.R <- function(M) {1-tem(M)^2/sd(as.matrix(M))^2}

#Write a function to find R while bootstrapping
tem.R.bootstrap <- function(splits){
  1-(tem.bootstrap(splits)^2/sd(as.matrix(analysis(splits)))^2)
}

#Function to calculate the CI on the bootstrapped sample
tem.CI.bootstrap <- function(M) {
  M %>%
    bootstraps(., times=10000) %>%
    mutate(TEM = map(splits, tem.bootstrap), R = map(splits, tem.R.bootstrap)) %>%
    unnest(TEM) %>%
    unnest(R) %>%
    summarize(tem.lower95 = quantile(TEM, 0.05/2),
              tem.upper95 = quantile(TEM, 1-(0.05/2)),
              R.lower95 = quantile(R, 0.05/2), 
              R.upper95 = quantile(R, 1-(0.05/2)))
}
```

# Data
The data are structured as follows: 
315 rows = 35 people * 3 replicate images * 3 registrations. Rows 1-105 is 1st registration; 106-210 is 2nd registration; 211-315 is 3rd registration. Within registration, P1_Rep1, P1_Rep2, P1_Rep3
21480 variables = x, y, and z of the 7160 coordinates of the mask
```{r}
#Read the 3DMD data 
md.35ind <- read_csv("XYZ_35ind_3DMD_7160LM.txt", col_names = F)
md.mqn <- read_csv("XYZ_Mqn_3DMD_7160LM.txt", col_names = F)

#Read in the Vectra data
v.35ind <- read_csv("XYZ_35ind_Vectra_7160LM.txt", col_names = F)
v.mqn <- read_csv("XYZ_Mqn_Vectra_7160LM.txt", col_names = F)
```

Column names
```{r}
#3dmd 
#35 ind
colnames(md.35ind) <- paste0(c("x", "y", "z"), rep(1:7160, each=3))

#Mannequin
colnames(md.mqn) <- paste0(c("x", "y", "z"), rep(1:7160, each=3))

#Vectra
#35 ind
colnames(v.35ind) <- paste0(c("x", "y", "z"), rep(1:7160, each=3))

#Mannequin
colnames(v.mqn) <- paste0(c("x", "y", "z"), rep(1:7160, each=3))
```

Add columns to the dataframe as grouping variables
```{r}
#3dmd
#35 ind
md.35ind$Individual <- factor(c(rep(paste0("P", rep(1:35, each=3)), times=3)), levels = c(paste0("P", 1:35)))
md.35ind$Replicate <- factor(c(rep(c("R1", "R2", "R3"), length = 315)))
md.35ind$Mapping <- factor(c(rep(c("M1", "M2", "M3"), each = 105)))

#Mannequin
md.mqn$Replicate <- factor(c(rep(c("R1", "R2", "R3"), times = 3)))
md.mqn$Mapping <- factor(c(rep(c("M1", "M2", "M3"), each = 3)))

#Vectra
#35 ind
v.35ind$Individual <- factor(c(rep(paste0("P", rep(1:35, each=3)), times=3)), levels = c(paste0("P", 1:35)))
v.35ind$Replicate <- factor(c(rep(c("R1", "R2", "R3"), length = 315)))
v.35ind$Mapping <- factor(c(rep(c("M1", "M2", "M3"), each = 105)))

#Mannequin
v.mqn$Replicate <- factor(c(rep(c("R1", "R2", "R3"), times = 3)))
v.mqn$Mapping <- factor(c(rep(c("M1", "M2", "M3"), each = 3)))
```

# Within-camera registration error
## Standard deviation
### 3DMD
#### 35ind
```{r}
# We want the standard deviation across mappings, so grouping by individual and replicate before calculating sd 
md.35ind.mapping.sd <- md.35ind %>%
  group_by(Individual, Replicate) %>%
  dplyr::select(-c(Mapping)) %>%
  summarise_all(.funs = sd)

#Plot
ggthemr(palette = 'fresh')
ggplot(melt(md.35ind.mapping.sd, id.vars = c("Individual", "Replicate")), aes(x = Individual, y = value))+geom_boxplot()+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5), legend.position = "none")+labs(y = "Standard deviation (mm)")
```

#### Mannequin
```{r}
# We want the standard deviation across mappings, so grouping by replicate before calculating sd 
md.mqn.mapping.sd <- md.mqn %>%
  group_by(Replicate) %>%
  dplyr::select(-c(Mapping)) %>%
  summarise_all(.funs = sd)

#Average across coordinates
rowMeans(md.mqn.mapping.sd[-1])

#Plot
ggplot(melt(md.mqn.mapping.sd, id.vars = c("Replicate")), aes(x = Replicate, y = value, fill = Replicate))+geom_boxplot()+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5), legend.position = "none")
```

### Vectra
#### 35ind
```{r}
# We want the standard deviation across mappings, so grouping by individual and replicate before calculating sd 
v.35ind.mapping.sd <- v.35ind %>%
  group_by(Individual, Replicate) %>%
  dplyr::select(-c(Mapping)) %>%
  summarise_all(.funs = sd)

#Plot
ggplot(melt(v.35ind.mapping.sd, id.vars = c("Individual", "Replicate")), aes(x = Individual, y = value))+geom_boxplot()+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5), legend.position = "none")+labs(y="Standard deviation (mm)")
```

#### Mannequin
```{r}
# We want the standard deviation across mappings, so grouping by replicate before calculating sd 
v.mqn.mapping.sd <- v.mqn %>%
  group_by(Replicate) %>%
  dplyr::select(-c(Mapping)) %>%
  summarise_all(.funs = sd)

#Average across coordinates
rowMeans(v.mqn.mapping.sd[-1])

#Plot
ggplot(melt(v.mqn.mapping.sd, id.vars = c("Replicate")), aes(x = Replicate, y = value, fill = Replicate))+geom_boxplot()+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5), legend.position = "none")
```

## Euclidean distance between mapping replicate centriod and each mapping iteration
### 3DMD
#### 35ind 
First calculate the centroid of each person's mapping replicates (replicate centroid)
```{r}
md.35ind.mapping.centroid <- md.35ind %>%
  group_by(Individual, Replicate) %>%
  dplyr::select(-c(Mapping)) %>%
  summarise_all(.funs = mean)
```

```{r}
#Create a matrix to store the Euclidean distances
md.35ind.mapping.euclid <- matrix(nrow = 315, ncol = 7160) 

#Create a matrix to store the average Euclidean distances across all three mappings
md.35ind.mapping.euclid.mean <- matrix(nrow = 105, ncol = 7160)

#Create a map of the columns since they are in x, y, z wide format
coord.cols <- seq(1,21480,3)

for (i in seq(1:105)){
  #Pull out the mappings being considered
  tmp <- as.matrix(md.35ind[c(i,i+105,i+210), 1:21480])

  #Add the centroid for these mappings
  tmp <- as.data.frame(rbind(tmp,md.35ind.mapping.centroid[i,-c(1:2)]))
  
  for (j in 1:length(coord.cols)){
    #Calculate euclidean distance and assign these to the appropriate rows, in the same order as they are in the original md.35ind dataframe
    md.35ind.mapping.euclid[i,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[3]
    md.35ind.mapping.euclid[i+105,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[5]
    md.35ind.mapping.euclid[i+210,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[6]
    
    #Now calculate the average and assign it
    md.35ind.mapping.euclid.mean[i,j] <- mean(c(dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[3], dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[5], dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[6]))
  }
}

#Transform the dataframe so that each column is an individual 
md.35ind.mapping.euclid.mean <- as.data.frame(t(md.35ind.mapping.euclid.mean))
colnames(md.35ind.mapping.euclid.mean) <- c(paste0("P", rep(1:35, each=3)))

#Plot
ggplot(melt(md.35ind.mapping.euclid.mean), aes(x = variable, y = value))+geom_boxplot()+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5), legend.position = "none")+labs(x = "Individual", y = "Eucidean distance (mm)", title = "Average registration error for 3dMD images")
```

Plot on face
```{r}
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = rowMeans(md.35ind.mapping.euclid.mean), title = "3dMD registration error \n Averaged across all participant images")
```

Technical error of measurement (TEM) calculation
We want to calculate the TEM for each landmark, across all images, with the three mappings as three "observers" so I should end up with a single list of 7160 numbers

I'm going to calculate relative TEM, but I don't think this is a valuable measurement because the distances themselves (distance between mappings and the centroid) is not a biological distance but one that we have calculated to assess mapping error. If it is a "good" mapping, then the distance will be very small, which will lead to quite large rTEM values.
```{r}
#Add columns to distance information as grouping variables 
#md.35ind.mapping.euclid <- as.data.frame(md.35ind.mapping.euclid)
#md.35ind.mapping.euclid$Individual <- factor(c(rep(paste0("P", rep(1:35, each=3)), times=3)), levels = c(paste0("P", 1:35)))
#md.35ind.mapping.euclid$Replicate <- factor(c(rep(c("R1", "R2", "R3"), length = 315)))
#md.35ind.mapping.euclid$Mapping <- factor(c(rep(c("M1", "M2", "M3"), each = 105)))

#For each landmark, arrange the three mappings of each image in columns and images in rows, then calculate the TEM and store it, then calculate relative TEM and coefficient of reliability. Run in parallel.
cores = detectCores()
cl <- makeCluster(cores[1]-1)
registerDoParallel(cl)

#Make a list with the mapping distances for each landmark
system.time(
  md.35ind.mapping.euclid.list <- foreach(i=1:7160, .packages=c('dplyr', 'tidyr')) %dopar% {
    md.35ind.mapping.euclid %>%
      select(c(i,7161:7163)) %>%
      spread(Mapping, colnames(.)[1]) %>%
      select(c("M1", "M2", "M3"))
    }
)
#Took 18 minutes to run

#Stop the cluster
stopCluster(cl)

#Calculate TEM
md.35ind.mapping.euclid.tem$TEM <- sapply(md.35ind.mapping.euclid.list, tem, simplify = TRUE)

#Calculate rTEM
md.35ind.mapping.euclid.tem$rTEM <- sapply(md.35ind.mapping.euclid.list, rTEM, simplify = TRUE)

#Calculate R
md.35ind.mapping.euclid.tem$R <- sapply(md.35ind.mapping.euclid.list , tem.R, simplify=TRUE)

#Make into dataframe
md.35ind.mapping.euclid.tem <- as.data.frame(md.35ind.mapping.euclid.tem)
```

```{r}
#Calculate the confidence intervals after bootstrapping 10,000 times 
#Make cluster
cl<-makeCluster(cores[1]-1, type="PSOCK")

#Load packages onto cores
clusterEvalQ(cl, c(library(dplyr), library(purrr), library(rsample)))
#Export needed functions to cores
clusterExport(cl, c("tem.CI.bootstrap", "tem.R.bootstrap", "tem.bootstrap"))

#Calculate CI for TEM and R
system.time(
  md.35ind.mapping.euclid.CI <- parLapply(cl, md.35ind.mapping.euclid.list, tem.CI.bootstrap)
)

#Close cluster
stopCluster(cl)

#Make CI stats into dataframe
md.35ind.mapping.euclid.CI <- list.rbind(md.35ind.mapping.euclid.CI)

#Bind the statistics all together
md.35ind.mapping.euclid.tem <- cbind(md.35ind.mapping.euclid.tem, md.35ind.mapping.euclid.CI)
```

Plot TEM on the face
```{r}
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = md.35ind.mapping.euclid.tem[,1], title = "Mapping TEM")
```
Plot coefficient of reliability on the face
```{r}
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = md.35ind.mapping.euclid.tem[,3], title = "Mapping Coefficient of Reliability")
```

#### Mannequin 
First calculate the centroid of each the mannequin mapping replicates (replicate centroid)
```{r}
md.mqn.mapping.centroid <- md.mqn %>%
  group_by(Replicate) %>%
  dplyr::select(-c(Mapping)) %>%
  summarise_all(.funs = mean)
```

Calculate the euclidean distance between each mapping and the centroid of the mappings
```{r}
#Create a matrix to store the Euclidean distances
md.mqn.mapping.euclid <- matrix(nrow = 9, ncol = 7160)

#Create a matrix to store the average Euclidean distances across all three mappings
md.mqn.mapping.euclid.mean <- matrix(nrow = 3, ncol = 7160)

#calculating the euclidean distances between the mapping centroid coordinates and each mapping replicate's coordinates
for (i in seq(1:3)){
  #Pull out the mappings being considered
  tmp <- as.matrix(md.mqn[c(i,i+3,i+6), 1:21480])

  #Add the centroid for these mappings
  tmp <- as.data.frame(rbind(tmp,md.mqn.mapping.centroid[i,-1]))
  
  for (j in 1:length(coord.cols)){
    #Calculate euclidean distance and assign these to the appropriate rows, in the same order as they are in the original md.35ind dataframe
    md.mqn.mapping.euclid[i,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[3]
    md.mqn.mapping.euclid[i+3,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[5]
    md.mqn.mapping.euclid[i+6,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[6]
    
    #Now calculate the average and assign it
    md.mqn.mapping.euclid.mean[i,j] <- mean(c(dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[3], dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[5], dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[6]))
  }
}

#Transform the dataframe so that each column is an individual 
md.mqn.mapping.euclid.mean <- as.data.frame(t(md.mqn.mapping.euclid.mean))
colnames(md.mqn.mapping.euclid.mean) <- c("Mqn1", "Mqn2", "Mqn3")

my_comparisons <- list(c("Mqn1", "Mqn2"), c("Mqn1", "Mqn3"), c("Mqn2", "Mqn3"))

#Plot
ggplot(melt(md.mqn.mapping.euclid.mean), aes(x = variable, y = value, fill = variable))+geom_boxplot()+stat_compare_means(comparisons = my_comparisons, paired = TRUE)+labs(title = "Average registration error for 3dMD mannequin images", subtitle = "Wilcoxon comparison of means", x = "Image", y = "Euclidean distance (mm)")+theme(legend.position = "none")
```

Plot on face
```{r}
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = rowMeans(md.mqn.mapping.euclid.mean), title = "3dMD registration error \n Averaged across mannequin replicates")
```


### Vectra 
#### 35ind 
First calculate the centroid of each person's mapping replicates (replicate centroid)
```{r}
v.35ind.mapping.centroid <- v.35ind %>%
  group_by(Individual, Replicate) %>%
  dplyr::select(-c(Mapping)) %>%
  summarise_all(.funs = mean)
```

Calculate the euclidean distance between each mapping and the centroid of the mappings
```{r}
#Create a matrix to store the Euclidean distances
v.35ind.mapping.euclid <- matrix(nrow = 315, ncol = 7160) 

#Create a matrix to store the average Euclidean distances across all three mappings
v.35ind.mapping.euclid.mean <- matrix(nrow = 105, ncol = 7160)

#Create a map of the columns since they are in x, y, z wide format
coord.cols <- seq(1,21480,3)

for (i in seq(1:105)){
  #Pull out the mappings being considered
  tmp <- as.matrix(v.35ind[c(i,i+105,i+210), 1:21480])

  #Add the centroid for these mappings
  tmp <- as.data.frame(rbind(tmp,v.35ind.mapping.centroid[i,-c(1,2)]))
  
  for (j in 1:length(coord.cols)){
    #Calculate euclidean distance and assign these to the appropriate rows, in the same order as they are in the original v.35ind dataframe
    v.35ind.mapping.euclid[i,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[3]
    v.35ind.mapping.euclid[i+105,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[5]
    v.35ind.mapping.euclid[i+210,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[6]
    
    #Now calculate the average and assign it
    v.35ind.mapping.euclid.mean[i,j] <- mean(c(dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[3], dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[5], dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[6]))
  }
}

#Transform the dataframe so that each column is an individual 
v.35ind.mapping.euclid.mean <- as.data.frame(t(v.35ind.mapping.euclid.mean))
colnames(v.35ind.mapping.euclid.mean) <- c(paste0("P", rep(1:35, each=3)))

#Plot
ggplot(melt(v.35ind.mapping.euclid.mean), aes(x = variable, y = value))+geom_boxplot()+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5), legend.position = "none")+labs(x = "Individual", y = "Eucidean distance (mm)", title = "Average registration error for Vectra images")
```

Plot on face
```{r}
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = rowMeans(v.35ind.mapping.euclid.mean), title = "Vectra registration error \n Averaged across all participant images")
```


#### Mannequin 
First calculate the centroid of each the mannequin mapping replicates (replicate centroid)
```{r}
v.mqn.mapping.centroid <- v.mqn %>%
  group_by(Replicate) %>%
  dplyr::select(-c(Mapping)) %>%
  summarise_all(.funs = mean)
```

Calculate the euclidean distance between each mapping and the centroid of the mappings
```{r}
#Create a matrix to store the Euclidean distances
v.mqn.mapping.euclid <- matrix(nrow = 9, ncol = 7160)

#Create a matrix to store the average Euclidean distances across all three mappings
v.mqn.mapping.euclid.mean <- matrix(nrow = 3, ncol = 7160)

#calculating the euclidean distances between the mapping centroid coordinates and each mapping replicate's coordinates
for (i in seq(1:3)){
  #Pull out the mappings being considered
  tmp <- as.matrix(v.mqn[c(i,i+3,i+6), 1:21480])

  #Add the centroid for these mappings
  tmp <- as.data.frame(rbind(tmp,v.mqn.mapping.centroid[i,-1]))
  
  for (j in 1:length(coord.cols)){
    #Calculate euclidean distance and assign these to the appropriate rows, in the same order as they are in the original v.35ind dataframe
    v.mqn.mapping.euclid[i,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[3]
    v.mqn.mapping.euclid[i+3,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[5]
    v.mqn.mapping.euclid[i+6,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[6]
    
    #Now calculate the average and assign it
    v.mqn.mapping.euclid.mean[i,j] <- mean(c(dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[3], dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[5], dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[6]))
  }
}

#Transform the dataframe so that each column is an individual 
v.mqn.mapping.euclid.mean <- as.data.frame(t(v.mqn.mapping.euclid.mean))
colnames(v.mqn.mapping.euclid.mean) <- c("Mqn1", "Mqn2", "Mqn3")

#Plot
ggplot(melt(v.mqn.mapping.euclid.mean), aes(x = variable, y = value, fill = variable))+geom_boxplot()+stat_compare_means(comparisons = my_comparisons, paired = TRUE)+labs(title = "Average registration error for Vectra mannequin images", subtitle = "Wilcoxon comparison of means", x = "Image", y = "Euclidean distance (mm)")+theme(legend.position = "none")
```

Plot on Face
```{r}
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = rowMeans(v.mqn.mapping.euclid.mean), title = "Vectra registration error \n Averaged across mannequin replicates")
```


## Compare 3dMD and Vectra for mapping error
### 35 ind 
```{r}
#3dmd
#Add columns for dplyr grouping 
md.35ind.mapping.euclid.distmean <- as.data.frame(t(md.35ind.mapping.euclid.mean))
md.35ind.mapping.euclid.distmean$Individual <- paste0("P", rep(1:35, each = 3))
md.35ind.mapping.euclid.distmean$Replicate <- paste0("R", rep(1:3, times = 35))

#Get average registration error for each person
md.35ind.mapping.euclid.regmean <- md.35ind.mapping.euclid.distmean %>%
  group_by(Individual) %>%
  dplyr::select(-c(Replicate)) %>%
  summarise_all(.funs = mean)

#Reorder the factor levels by number
md.35ind.mapping.euclid.regmean$Individual <- factor(md.35ind.mapping.euclid.regmean$Individual, levels = c(paste0("P", 1:35)))

#Average each person to get the 3dMD value per person 
md.35ind.mapping.euclid.pmean <- rowMeans(md.35ind.mapping.euclid.regmean[-1])

#Vectra
#Add columns for dplyr grouping 
v.35ind.mapping.euclid.distmean <- as.data.frame(t(v.35ind.mapping.euclid.mean))
v.35ind.mapping.euclid.distmean$Individual <- paste0("P", rep(1:35, each = 3))
v.35ind.mapping.euclid.distmean$Replicate <- paste0("R", rep(1:3, times = 35))

#Get average registration error for each person
v.35ind.mapping.euclid.regmean <- v.35ind.mapping.euclid.distmean %>%
  group_by(Individual) %>%
  dplyr::select(-c(Replicate)) %>%
  summarise_all(.funs = mean)

#Reorder the factor levels by number
v.35ind.mapping.euclid.regmean$Individual <- factor(v.35ind.mapping.euclid.regmean$Individual, levels = c(paste0("P", 1:35)))

#Average each person to get the Vectra value per person 
v.35ind.mapping.euclid.pmean <- rowMeans(v.35ind.mapping.euclid.regmean[-1])

#Bind the md and vectra results together to plot
bothcam.35ind.mapping.euclid.pmean <- cbind(md.35ind.mapping.euclid.pmean, v.35ind.mapping.euclid.pmean)
colnames(bothcam.35ind.mapping.euclid.pmean) <- c("3dMD", "Vectra")

#Plot and add p-value of Wilcoxon comparison of means 
p <- ggplot(melt(bothcam.35ind.mapping.euclid.pmean), aes(x = Var2, y=value, fill = Var2))+geom_boxplot()+geom_point(colour = "black", size = 0.9)+geom_line(aes(group = Var1), colour = "black", alpha = 0.5)+stat_compare_means(paired = TRUE, label.x = 2)+ylab("Euclidean distance (mm)")+xlab("Camera")+ggtitle("Average registration error")+theme(legend.position = "none", axis.title = element_text())
ggsave(plot =  p, filename =  "Figures/AvgRegistrationErrorPerCamera.pdf", device = "pdf", width = 6, height = 4, units = "in")
p
```

Graphing per person instead of overall camera
```{r}
bothcam.35ind.mapping.euclid.regmean <- as.data.frame(rbind(md.35ind.mapping.euclid.regmean, v.35ind.mapping.euclid.regmean))
bothcam.35ind.mapping.euclid.regmean$Camera <- c(rep("3dMD", times = 35), rep("Vectra", times = 35))

p <- ggplot(melt(bothcam.35ind.mapping.euclid.regmean, id.vars = c("Individual", "Camera")), aes(x = Individual, y = value, fill = Camera))+geom_boxplot(outlier.size = 0.5)+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5), axis.title = element_text(), legend.position = "bottom")+labs(title = "Average registration error", y = "Euclidean distance (mm)")
ggsave(plot =  p, filename =  "Figures/AvgRegistrationErrorPerParticipant.pdf", device = "pdf", width = 6, height = 4, units = "in")
p
```

Wilcoxon text for differences in camera per person.
```{r}
compare_means(data = melt(bothcam.35ind.mapping.euclid.regmean, id.vars = c("Individual", "Camera")), formula = value ~ Camera, group.by = "Individual", paired = TRUE)
```

### Mannequin
```{r}
bothcam.mqn.mapping.euclid.mean <- as.data.frame(t(cbind(md.mqn.mapping.euclid.mean, v.mqn.mapping.euclid.mean)))
bothcam.mqn.mapping.euclid.mean$Camera <- c(rep("3dMD", times = 3), rep("Vectra", times = 3))
bothcam.mqn.mapping.euclid.mean$Replicate <- c(paste0("R", rep(1:3, times = 2)))

p<-ggplot(melt(bothcam.mqn.mapping.euclid.mean, id.vars = c("Camera", "Replicate")), aes(x = Replicate, y = value, fill = Camera))+geom_boxplot()+stat_compare_means(paired = TRUE, label = "p.format", label.y = 1)+labs(title = "Average registration error for mannequin images", subtitle = "Kruskal-Wallis paired test", y = "Euclidean distance (mm)")+theme(axis.title = element_text())
ggsave(plot =  p, filename =  "Figures/AvgRegistrationErrorMannequin.pdf", device = "pdf", width = 6, height = 4, units = "in")
p
```

# Intra-camera error 
## GPA align the three replicate images of each person 
3dMD
```{r}
#Give each matrix column names. 
#35 ind
colnames(md.35ind.mapping.centroid[-c(1,2)]) <- paste0(c("x", "y", "z"), rep(1:7160, each=3))

#Mannequin
colnames(md.mqn) <- paste0(c("x", "y", "z"), rep(1:7160, each=3))

#Convert the 3DMD dataframe to geomorph format
md.35ind.mapping.centroid.geomorph <- arrayspecs(A=md.35ind.mapping.centroid[-c(1,2)], p = 7160, k = 3)
md.mqn.mapping.centroid.geomorph <- arrayspecs(A=md.mqn.mapping.centroid[2:21481], p = 7160, k = 3)

#GPA align without scaling or reflecting
md.35ind.mapping.centroid.gpa <- ProcGPA(md.35ind.mapping.centroid.geomorph, scale = FALSE, CSinit = FALSE, silent = TRUE, reflection = FALSE)
md.mqn.mapping.centroid.gpa <- ProcGPA(md.mqn.mapping.centroid.geomorph, scale = FALSE, CSinit = FALSE, silent = TRUE, reflection = FALSE)

#Take out the aligned coordinates
md.35ind.mapping.centroid.aligned <- two.d.array(md.35ind.mapping.centroid.gpa$rotated)
md.mqn.mapping.centroid.aligned <- two.d.array(md.mqn.mapping.centroid.gpa$rotated)
```

Vectra
```{r}
#Give each matrix column names. 
#35 ind
colnames(v.35ind.mapping.centroid[-c(1,2)]) <- paste0(c("x", "y", "z"), rep(1:7160, each=3))

#Mannequin
colnames(v.mqn) <- paste0(c("x", "y", "z"), rep(1:7160, each=3))

#Convert the V dataframe to geomorph format
v.35ind.mapping.centroid.geomorph <- arrayspecs(A=v.35ind.mapping.centroid[-c(1,2)], p = 7160, k = 3)
v.mqn.mapping.centroid.geomorph <- arrayspecs(A=v.mqn.mapping.centroid[2:21481], p = 7160, k = 3)

#GPA align without scaling or reflecting
v.35ind.mapping.centroid.gpa <- ProcGPA(v.35ind.mapping.centroid.geomorph, scale = FALSE, CSinit = FALSE, silent = TRUE, reflection = FALSE)
v.mqn.mapping.centroid.gpa <- ProcGPA(v.mqn.mapping.centroid.geomorph, scale = FALSE, CSinit = FALSE, silent = TRUE, reflection = FALSE)

#Take out the aligned coordinates
v.35ind.mapping.centroid.aligned <- two.d.array(v.35ind.mapping.centroid.gpa$rotated)
v.mqn.mapping.centroid.aligned <- two.d.array(v.mqn.mapping.centroid.gpa$rotated)
```

## Standard deviation
### 3DMD
#### Mannequin
```{r}
#calulating the standard deviation of all dimensions for all landmarks
md.mqn.intra.sd <-apply(md.mqn.mapping.centroid.aligned,2,function(x) sd(x))
```

Average SD per axis, then plot 
```{r}
#calculating the average SD per axis
#X
md.mqn.intra.sd.x <- md.mqn.intra.sd[c(seq(1,length(md.mqn.intra.sd),3))]
md.mqn.intra.sd.x <- as.data.frame(md.mqn.intra.sd.x)
colnames(md.mqn.intra.sd.x) <- "X"
#Y
md.mqn.intra.sd.y <- md.mqn.intra.sd[c(seq(2,length(md.mqn.intra.sd),3))]
md.mqn.intra.sd.y <- as.data.frame(md.mqn.intra.sd.y)
colnames(md.mqn.intra.sd.y) <- "Y"
#Z
md.mqn.intra.sd.z <- md.mqn.intra.sd[c(seq(3,length(md.mqn.intra.sd),3))]
md.mqn.intra.sd.z <- as.data.frame(md.mqn.intra.sd.z)
colnames(md.mqn.intra.sd.z) <- "Z"

#Combine the above into one dataframe 
md.mqn.intra.sd.axis <- cbind(md.mqn.intra.sd.x,md.mqn.intra.sd.y,md.mqn.intra.sd.z)

#Remove old files
rm(md.mqn.intra.sd.x,md.mqn.intra.sd.y,md.mqn.intra.sd.z)

#Melt the x,y,z standard deviations into two columns: variable and value, then plot
ggplot(melt(md.mqn.intra.sd.axis), aes(x=variable,y=value))+geom_boxplot()+ggtitle("3dMD Mqn average SD per axis")
```

Plot these on a face 
```{r}
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = md.mqn.intra.sd.axis$X, title = "Average X standard deviation")
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = md.mqn.intra.sd.axis$Y, title = "Average Y standard deviation")
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = md.mqn.intra.sd.axis$Z, title = "Average Z standard deviation")
```

#### 35 ind
```{r}
#creating a matrix to store the standard deviations of the MD coords
md.35ind.intra.sd <- matrix(nrow = 35, ncol = 21480)

#Each third row is a new person, so need a sequence by three from 1 to 103 
rows <- seq(1,103,3)

for (i in 1:length(rows)){
  #pulling out columns for each person
  tmp <- md.35ind.mapping.centroid.aligned[c(rows[i],rows[i]+1,rows[i]+2),]
  #calulating the standard deviation of all dimensions for all landmarks
  md.35ind.intra.sd[i,] <-apply(tmp,2,function(x) sd(x))
}
```

Average SD per axis, then plot 
```{r}
#calculating the average SD per axis
#X
md.35ind.intra.sd.x <- md.35ind.intra.sd[, c(seq(1,ncol(md.35ind.intra.sd),3))]
md.35ind.intra.sd.x.avg <- as.data.frame(colMeans(x=md.35ind.intra.sd.x))
colnames(md.35ind.intra.sd.x.avg) <- "X"
#Y
md.35ind.intra.sd.y <- md.35ind.intra.sd[, c(seq(2,ncol(md.35ind.intra.sd),3))]
md.35ind.intra.sd.y.avg <- as.data.frame(colMeans(x=md.35ind.intra.sd.y))
colnames(md.35ind.intra.sd.y.avg) <- "Y"
#Z
md.35ind.intra.sd.z <- md.35ind.intra.sd[, c(seq(3,ncol(md.35ind.intra.sd),3))]
md.35ind.intra.sd.z.avg <- as.data.frame(colMeans(x=md.35ind.intra.sd.z))
colnames(md.35ind.intra.sd.z.avg) <- "Z"

#Combine the above into one dataframe 
md.35ind.intra.sd.axis.avg <- cbind(md.35ind.intra.sd.x.avg,md.35ind.intra.sd.y.avg,md.35ind.intra.sd.z.avg)
colnames(md.35ind.intra.sd.axis.avg) <- c("X","Y","Z")
#Remove old files
rm(md.35ind.intra.sd.x.avg,md.35ind.intra.sd.y.avg,md.35ind.intra.sd.z.avg)

#Melt the x,y,z standard deviations into two columns: variable and value, then plot
ggplot(melt(md.35ind.intra.sd.axis.avg), aes(x=variable,y=value))+geom_boxplot()+ggtitle("3dMD average SD per axis")
```

Plot these on a face 
```{r}
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = md.35ind.intra.sd.axis.avg$X, title = "Average X standard deviation")
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = md.35ind.intra.sd.axis.avg$Y, title = "Average Y standard deviation")
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = md.35ind.intra.sd.axis.avg$Z, title = "Average Z standard deviation")
```

### Vectra
#### Mannequin
```{r}
#calulating the standard deviation of all dimensions for all landmarks
v.mqn.intra.sd <-apply(v.mqn.mapping.centroid.aligned,2,function(x) sd(x))
```

Average SD per axis, then plot 
```{r}
#calculating the average SD per axis
#X
v.mqn.intra.sd.x <- v.mqn.intra.sd[c(seq(1,length(v.mqn.intra.sd),3))]
v.mqn.intra.sd.x <- as.data.frame(v.mqn.intra.sd.x)
colnames(v.mqn.intra.sd.x) <- "X"
#Y
v.mqn.intra.sd.y <- v.mqn.intra.sd[c(seq(2,length(v.mqn.intra.sd),3))]
v.mqn.intra.sd.y <- as.data.frame(v.mqn.intra.sd.y)
colnames(v.mqn.intra.sd.y) <- "Y"
#Z
v.mqn.intra.sd.z <- v.mqn.intra.sd[c(seq(3,length(v.mqn.intra.sd),3))]
v.mqn.intra.sd.z <- as.data.frame(v.mqn.intra.sd.z)
colnames(v.mqn.intra.sd.z) <- "Z"

#Combine the above into one dataframe 
v.mqn.intra.sd.axis <- cbind(v.mqn.intra.sd.x,v.mqn.intra.sd.y,v.mqn.intra.sd.z)

#Remove old files
rm(v.mqn.intra.sd.x,v.mqn.intra.sd.y,v.mqn.intra.sd.z)

#Melt the x,y,z standard deviations into two columns: variable and value, then plot
ggplot(melt(v.mqn.intra.sd.axis), aes(x=variable,y=value))+geom_boxplot()+ggtitle("Vectra Mqn average SD per axis")
```

Plot these on a face 
```{r}
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = v.mqn.intra.sd.axis$X, title = "Average X standard deviation")
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = v.mqn.intra.sd.axis$Y, title = "Average Y standard deviation")
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = v.mqn.intra.sd.axis$Z, title = "Average Z standard deviation")
```

#### 35 ind
```{r}
#creating a matrix to store the standard deviations of the Vectra coords
v.35ind.intra.sd <- matrix(nrow = 35, ncol = 21480)

#Each third row is a new person, so need a sequence by three from 1 to 103 
rows <- seq(1,103,3)

for (i in 1:length(rows)){
  #pulling out columns for each person
  tmp <- v.35ind.mapping.centroid.aligned[c(rows[i],rows[i]+1,rows[i]+2),]
  #calulating the standard deviation of all dimensions for all landmarks
  v.35ind.intra.sd[i,] <-apply(tmp,2,function(x) sd(x))
}
```

Average SD per axis, then plot 
```{r}
#calculating the average SD per axis
#X
v.35ind.intra.sd.x <- v.35ind.intra.sd[, c(seq(1,ncol(v.35ind.intra.sd),3))]
v.35ind.intra.sd.x.avg <- as.data.frame(colMeans(x=v.35ind.intra.sd.x))
colnames(v.35ind.intra.sd.x.avg) <- "X"
#Y
v.35ind.intra.sd.y <- v.35ind.intra.sd[, c(seq(2,ncol(v.35ind.intra.sd),3))]
v.35ind.intra.sd.y.avg <- as.data.frame(colMeans(x=v.35ind.intra.sd.y))
colnames(v.35ind.intra.sd.y.avg) <- "Y"
#Z
v.35ind.intra.sd.z <- v.35ind.intra.sd[, c(seq(3,ncol(v.35ind.intra.sd),3))]
v.35ind.intra.sd.z.avg <- as.data.frame(colMeans(x=v.35ind.intra.sd.z))
colnames(v.35ind.intra.sd.z.avg) <- "Z"

#Combine the above into one dataframe 
v.35ind.intra.sd.axis.avg <- cbind(v.35ind.intra.sd.x.avg,v.35ind.intra.sd.y.avg,v.35ind.intra.sd.z.avg)
colnames(v.35ind.intra.sd.axis.avg) <- c("X","Y","Z")
#Remove old files
rm(v.35ind.intra.sd.x.avg,v.35ind.intra.sd.y.avg,v.35ind.intra.sd.z.avg)

#Melt the x,y,z standard deviations into two columns: variable and value, then plot
ggplot(melt(v.35ind.intra.sd.axis.avg), aes(x=variable,y=value))+geom_boxplot()+ggtitle("Vectra average SD per axis")
```

Plot these on a face 
```{r}
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = v.35ind.intra.sd.axis.avg$X, title = "Average X standard deviation")
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = v.35ind.intra.sd.axis.avg$Y, title = "Average Y standard deviation")
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = v.35ind.intra.sd.axis.avg$Z, title = "Average Z standard deviation")
```

## Euclidean distance between replicate centroid and each replicate
### 3dMD
#### 35 ind
First calculate the centroid of each person's replicates (replicate centroid)
```{r}
#Create a matrix to store the replicate centroids of the MD coords
md.35ind.rep.centroid <- matrix(nrow = 35, ncol = 21480)

rows <- seq(1,103,3)

#Calculate the centroid for each person
for (i in 1:length(rows)){
  #pulling out rows for each person
  tmp <- md.35ind.mapping.centroid.aligned[c(rows[i],rows[i]+1,rows[i]+2),]
  #calulating the means of all dimensions for all landmarks
  md.35ind.rep.centroid[i,] <-apply(tmp,2,function(x) mean(x))
}
```

Calculate the euclidean distance between each person's centroid face and the replicates
```{r}
#Create a matrix to store the Euclidean distances
md.35ind.intra.tocent.euclid <- matrix(nrow = 105, ncol = 7160)

#Create a matrix to store the average Euclidean distances
md.35ind.intra.tocent.euclid.mean <- matrix(nrow = 35, ncol = 7160)

#calculating the euclidean distances between the centroid coordinates and each replicate's coordinates
for (i in seq(1:35)){
    #Pull out the mappings being considered
    tmp <- md.35ind.mapping.centroid.aligned[c(rows[i],rows[i]+1,rows[i]+2),]

    #Add the centroid for these mappings
    tmp <- as.data.frame(rbind(tmp,md.35ind.rep.centroid[i,]))
  
  for (j in 1:length(coord.cols)){
    #Replicate 1
    md.35ind.intra.tocent.euclid[rows[i],j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[3]
    #Replicate 2
    md.35ind.intra.tocent.euclid[rows[i]+1,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[5]
      #Replicate 3
    md.35ind.intra.tocent.euclid[rows[i]+2,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[6]
    
    #Calculate the average of the euclidean distances and assign it
    md.35ind.intra.tocent.euclid.mean[i,j] <- mean(c(md.35ind.intra.tocent.euclid[rows[i],j], md.35ind.intra.tocent.euclid[rows[i]+1,j], md.35ind.intra.tocent.euclid[rows[i]+2,j]))
  }
}
```

Plot on a face 
```{r}
#Take the global average of the Euclidean distances for the heat map 
md.35ind.intra.tocent.euclid.allmean <- as.data.frame(colMeans(x=md.35ind.intra.tocent.euclid.mean))
colnames(md.35ind.intra.tocent.euclid.allmean) <- "X"

Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = md.35ind.intra.tocent.euclid.allmean$X, title = "3dMD biological error \n Averaged across all participants")
```

Boxplot of average Euclidean distance between person's centroid and replicates 
```{r}
rownames(md.35ind.intra.tocent.euclid.mean) <- paste0("P", 1:35)

ggplot(melt(t(md.35ind.intra.tocent.euclid.mean)), aes(x=factor(Var2),y=value))+geom_boxplot()+ggtitle("Average biological error for 3dMD images") + theme(legend.position = "none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust =1)) + ylab("Euclidean distance (mm)")+xlab("Individual")
```

#### Mannequin
First calculate the centroid of the mannequin replicates (replicate centroid)
```{r}
#calulating the average of all dimensions for all landmarks
md.mqn.rep.centroid <-apply(md.mqn.mapping.centroid.aligned,2,function(x) mean(x))
```

Calculate the euclidean distance between each person's centroid face and the replicates
```{r}
#Create a matrix to store the Euclidean distances
md.mqn.intra.tocent.euclid <- matrix(nrow = 3, ncol = 7160)

#Create a matrix to store the average Euclidean distances
md.mqn.intra.tocent.euclid.mean <- matrix(nrow = 1, ncol = 7160)

#Bind together the mannequin data with the centroid of the mannequin
tmp <- as.data.frame(rbind(md.mqn.mapping.centroid.aligned, md.mqn.rep.centroid))

#calculating the euclidean distances between the centroid coordinates and each replicate's coordinates
for (j in 1:length(coord.cols)){
  #Replicate 1
  md.mqn.intra.tocent.euclid[1,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[3]
  #Replicate 2
  md.mqn.intra.tocent.euclid[2,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[5]
  #Replicate 3
  md.mqn.intra.tocent.euclid[3,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[6]

    
  #Calculate the average of the euclidean distances and assign it
  md.mqn.intra.tocent.euclid.mean[1,j] <- mean(c(md.mqn.intra.tocent.euclid[1,j], md.mqn.intra.tocent.euclid[2,j], md.mqn.intra.tocent.euclid[3,j]))
}

```

Plot on a face 
```{r}
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = md.mqn.intra.tocent.euclid.mean, title = "3dMD 'biological' error \n Averaged across mannequin replicates")
```

Boxplot of average Euclidean distance between mannequin centroid and replicates 
```{r}
ggplot(as.data.frame(t(md.mqn.intra.tocent.euclid.mean)), aes(x=V1))+geom_histogram()+ggtitle("Euclidean Distance between replicate centroid and replicates") + theme(legend.position = "none") + xlab("Euclidean distance")
```

### Vectra
#### 35 ind
First calculate the centroid of each person's replicates (replicate centroid)
```{r}
#Create a matrix to store the replicate centroids of the v coords
v.35ind.rep.centroid <- matrix(nrow = 35, ncol = 21480)

rows <- seq(1,103,3)

#Calculate the centroid for each person
for (i in 1:length(rows)){
  #pulling out rows for each person
  tmp <- v.35ind.mapping.centroid.aligned[c(rows[i],rows[i]+1,rows[i]+2),]
  #calulating the means of all dimensions for all landmarks
  v.35ind.rep.centroid[i,] <-apply(tmp,2,function(x) mean(x))
}
```

Calculate the euclidean distance between each person's centroid face and the replicates
```{r}
#Create a matrix to store the Euclidean distances
v.35ind.intra.tocent.euclid <- matrix(nrow = 105, ncol = 7160)

#Create a matrix to store the average Euclidean distances
v.35ind.intra.tocent.euclid.mean <- matrix(nrow = 35, ncol = 7160)

#calculating the euclidean distances between the centroid coordinates and each replicate's coordinates
for (i in seq(1:35)){
    #Pull out the mappings being considered
    tmp <- v.35ind.mapping.centroid.aligned[c(rows[i],rows[i]+1,rows[i]+2),]

    #Add the centroid for these mappings
    tmp <- as.data.frame(rbind(tmp,v.35ind.rep.centroid[i,]))
  
  for (j in 1:length(coord.cols)){
    #Replicate 1
    v.35ind.intra.tocent.euclid[rows[i],j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[3]
    #Replicate 2
    v.35ind.intra.tocent.euclid[rows[i]+1,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[5]
      #Replicate 3
    v.35ind.intra.tocent.euclid[rows[i]+2,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[6]
    
    #Calculate the average of the euclidean distances and assign it
    v.35ind.intra.tocent.euclid.mean[i,j] <- mean(c(v.35ind.intra.tocent.euclid[rows[i],j], v.35ind.intra.tocent.euclid[rows[i]+1,j], v.35ind.intra.tocent.euclid[rows[i]+2,j]))
  }
}
```

Plot on a face 
```{r}
#Take the global average of the Euclidean distances for the heat map 
v.35ind.intra.tocent.euclid.allmean <- as.data.frame(colMeans(x=v.35ind.intra.tocent.euclid.mean))
colnames(v.35ind.intra.tocent.euclid.allmean) <- "X"

Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = v.35ind.intra.tocent.euclid.allmean$X, title = "Vectra biological error \n Averaged across all participants")
```

Boxplot of average Euclidean distance between person's centroid and replicates 
```{r}
rownames(v.35ind.intra.tocent.euclid.mean) <- paste0("P", 1:35)

ggplot(melt(t(v.35ind.intra.tocent.euclid.mean)), aes(x=Var2,y=value))+geom_boxplot()+ggtitle("Average Euclidean Distance between replicate centroid and replicates") + theme(legend.position = "none", axis.text.x = element_text(angle = 90, vjust = 0.5, hjust =1)) + ylab("Euclidean distance")+xlab("Individual")
```

#### Mannequin
First calculate the centroid of the mannequin replicates (replicate centroid)
```{r}
#calulating the average of all dimensions for all landmarks
v.mqn.rep.centroid <-apply(v.mqn.mapping.centroid.aligned,2,function(x) mean(x))
```

Calculate the euclidean distance between each person's centroid face and the replicates
```{r}
#Create a matrix to store the Euclidean distances
v.mqn.intra.tocent.euclid <- matrix(nrow = 3, ncol = 7160)

#Create a matrix to store the average Euclidean distances
v.mqn.intra.tocent.euclid.mean <- matrix(nrow = 1, ncol = 7160)

#Bind together the mannequin data with the centroid of the mannequin
tmp <- as.data.frame(rbind(v.mqn.mapping.centroid.aligned, v.mqn.rep.centroid))

#calculating the euclidean distances between the centroid coordinates and each replicate's coordinates
for (j in 1:length(coord.cols)){
  #Replicate 1
  v.mqn.intra.tocent.euclid[1,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[3]
  #Replicate 2
  v.mqn.intra.tocent.euclid[2,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[5]
  #Replicate 3
  v.mqn.intra.tocent.euclid[3,j] <- dist(as.matrix(tmp[paste(coord.cols[j]):paste(coord.cols[j]+2)]))[6]

    
  #Calculate the average of the euclidean distances and assign it
  v.mqn.intra.tocent.euclid.mean[1,j] <- mean(c(v.mqn.intra.tocent.euclid[1,j], v.mqn.intra.tocent.euclid[2,j], v.mqn.intra.tocent.euclid[3,j]))
}
```

Plot on a face 
```{r}
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = v.mqn.intra.tocent.euclid.mean, title = "Vectra 'biological' error \n Averaged across mannequin replicates")
```

Boxplot of average Euclidean distance between mannequin centroid and replicates 
```{r}
ggplot(as.data.frame(t(v.mqn.intra.tocent.euclid.mean)), aes(x=V1))+geom_histogram()+ggtitle("Euclidean Distance between replicate centroid and replicates") + theme(legend.position = "none") + xlab("Euclidean distance")
```

### Compare the 3dMD and Vectra
#### 35 ind
```{r}
#Average across all landmarks and put in same data frame
bothcam.35ind.intra.tocent.euclid.pmean <- cbind(rowMeans(md.35ind.intra.tocent.euclid.mean), rowMeans(v.35ind.intra.tocent.euclid.mean))
colnames(bothcam.35ind.intra.tocent.euclid.pmean) <- c("3dMD", "Vectra")

p <- ggplot(melt(bothcam.35ind.intra.tocent.euclid.pmean), aes(x = Var2, y=value, fill = Var2))+geom_boxplot()+geom_point(colour = "black", size = 0.9)+geom_line(aes(group = Var1), colour = "black", alpha = 0.5)+stat_compare_means(paired = TRUE, label.x = 0.55)+ylab("Euclidean distance (mm)")+xlab("Camera")+ggtitle("Average biological error")+theme(legend.position = "none", axis.title = element_text())
ggsave(plot =  p, filename =  "Figures/AvgBiologicalErrorPerCamera.pdf", device = "pdf", width = 6, height = 4, units = "in")
p
```

Graphing per person instead of overall camera
```{r}
bothcam.35ind.intra.tocent.euclid.mean <- as.data.frame(rbind(md.35ind.intra.tocent.euclid.mean, v.35ind.intra.tocent.euclid.mean))
bothcam.35ind.intra.tocent.euclid.mean$Individual <- c(rep(paste0("P", rep(1:35)), times = 2))
bothcam.35ind.intra.tocent.euclid.mean$Camera <- c(rep("3dMD", times = 35), rep("Vectra", times = 35))

#Reorder the rows by number
bothcam.35ind.intra.tocent.euclid.mean$Individual <- factor(bothcam.35ind.intra.tocent.euclid.mean$Individual, levels = c(paste0("P", 1:35)))

p <- ggplot(melt(bothcam.35ind.intra.tocent.euclid.mean, id.vars = c("Individual", "Camera")), aes(x = Individual, y = value, fill = Camera))+geom_boxplot(outlier.size = 0.5)+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5), axis.title = element_text(), legend.position = "bottom")+labs(title = "Average biological error", y = "Euclidean distance (mm)")
ggsave(plot =  p, filename =  "Figures/AvgBiologicalErrorPerParticipant.pdf", device = "pdf", width = 6, height = 4, units = "in")
p
```

Wilcoxon text for differences in camera per person
```{r}
compare_means(data = melt(bothcam.35ind.intra.tocent.euclid.mean, id.vars = c("Individual", "Camera")), formula = value ~ Camera, group.by = "Individual", paired = TRUE)
```


#### Mannequin
```{r}
bothcam.mqn.intra.tocent.euclid.mean <- t(rbind(md.mqn.intra.tocent.euclid.mean, v.mqn.intra.tocent.euclid.mean))
colnames(bothcam.mqn.intra.tocent.euclid.mean) <- c("3dMD", "Vectra")

p <- ggplot(melt(bothcam.mqn.intra.tocent.euclid.mean), aes(x = Var2, y = value, fill = Var2))+geom_boxplot()+stat_compare_means(paired = TRUE, label.x = 0.55)+labs(title = "Average 'biological' error for mannequin images", y = "Euclidean distance (mm)", x = "Camera")+theme(axis.title = element_text(), legend.position = "none")
ggsave(plot =  p, filename =  "Figures/AvgBiologicalErrorMannequin.pdf", device = "pdf", width = 6, height = 4, units = "in")
p
```

# Inter-camera error
## Combine and align coordinates from each camera
### 35 ind
```{r}
#Create a new dataframe with the average of each person's replicates for the MD and Vectra. m
bothcam.35ind <- rbind(md.35ind.rep.centroid, v.35ind.rep.centroid)
colnames(bothcam.35ind) <- paste0(c("x", "y", "z"), rep(1:7160, each=3))
rownames(bothcam.35ind) <- c(paste0("MD.P", 1:35), paste0("V.P", 1:35))

#Convert the dataframe to geomorph format
bothcam.35ind.geomorph <- arrayspecs(A=bothcam.35ind, p = 7160, k = 3)

#GPA align without scaling or reflecting
bothcam.35ind.gpa <- ProcGPA(bothcam.35ind.geomorph, scale = FALSE, CSinit = FALSE, silent = TRUE, reflection = FALSE)

#Take out the aligned coordinates
bothcam.35ind.aligned <- two.d.array(bothcam.35ind.gpa$rotated)
```

### Mannequin
```{r}
#Create a new dataframe with the average of each person's replicates for the MD and Vectra. m
bothcam.mqn <- rbind(md.mqn.rep.centroid, v.mqn.rep.centroid)
colnames(bothcam.mqn) <- paste0(c("x", "y", "z"), rep(1:7160, each=3))
rownames(bothcam.mqn) <- c("md.mqn", "v.mqn")

#Convert the dataframe to geomorph format
bothcam.mqn.geomorph <- arrayspecs(A=bothcam.mqn, p = 7160, k = 3)

#GPA align without scaling or reflecting
bothcam.mqn.gpa <- ProcGPA(bothcam.mqn.geomorph, scale = FALSE, CSinit = FALSE, silent = TRUE, reflection = FALSE)

#Take out the aligned coordinates
bothcam.mqn.aligned <- two.d.array(bothcam.mqn.gpa$rotated)
```

## Standard deviation between 3dMD and Vectra
### 35 ind
```{r}
#Empty matrix to store standard deviation values
bothcam.35ind.inter.sd <- matrix(nrow = 35, ncol = 21480)

for (i in 1:21480){
  #Pull out 3dMD coordinates and Vectra coordinates for each person
  tmp <- cbind(bothcam.35ind.aligned[1:35,i],bothcam.35ind.aligned[36:70,i])
  #Calculate and store standard deviation
  bothcam.35ind.inter.sd[,i] <- apply(tmp,1,sd)
}
```

Plot standard deviation per person
```{r}
rownames(bothcam.35ind.inter.sd) <- paste0("P", 1:35)

ggplot(melt(t(bothcam.35ind.inter.sd)), aes(x=Var2,y=value))+geom_boxplot()+ggtitle("Standard deviation between MD and Vectra") + theme(legend.position = "none")+xlab("Individual")+ylab("Standard Deviation")
```

Calculate average per axis
```{r}
#X
bothcam.35ind.inter.sd.x.avg <- as.data.frame(colMeans(bothcam.35ind.inter.sd[, c(seq(1,ncol(bothcam.35ind.inter.sd),3))]))

#Y
bothcam.35ind.inter.sd.y.avg <- as.data.frame(colMeans(bothcam.35ind.inter.sd[, c(seq(2,ncol(bothcam.35ind.inter.sd),3))]))

#Z
bothcam.35ind.inter.sd.z.avg <- as.data.frame(colMeans(bothcam.35ind.inter.sd[, c(seq(3,ncol(bothcam.35ind.inter.sd),3))]))

#Combine the above into one dataframe
bothcam.35ind.inter.sd.axis.avg <- cbind(bothcam.35ind.inter.sd.x.avg, bothcam.35ind.inter.sd.y.avg, bothcam.35ind.inter.sd.z.avg)
colnames(bothcam.35ind.inter.sd.axis.avg) <- c("X","Y","Z")
colMeans(bothcam.35ind.inter.sd.axis.avg)

#Remove old files
rm(bothcam.35ind.inter.sd.x.avg, bothcam.35ind.inter.sd.y.avg, bothcam.35ind.inter.sd.z.avg)

#Plot
ggplot(melt(bothcam.35ind.inter.sd.axis.avg), aes(x=variable, y = value))+geom_boxplot()+ggtitle("Standard deviation between MD and Vectra") + theme(legend.position = "none")+xlab("Axis")+ylab("Standard Deviation")
```

### Mannequin
Plot standard deviation per person
```{r}
bothcam.mqn.inter.sd <- matrix(nrow=1, ncol = 21480)

#Calculate standard deviation
bothcam.mqn.inter.sd[1,] <- apply(bothcam.mqn.aligned, 2, sd)

ggplot(as.data.frame(t(bothcam.mqn.inter.sd)), aes(x=V1))+geom_histogram()+ggtitle("Standard deviation between MD and Vectra") + theme(legend.position = "none")+xlab("Standard Deviation")
```

Per axis
```{r}
#X
bothcam.mqn.inter.sd.x <- as.data.frame(bothcam.mqn.inter.sd[c(seq(1,length(bothcam.mqn.inter.sd),3))])

#Y
bothcam.mqn.inter.sd.y <- as.data.frame(bothcam.mqn.inter.sd[c(seq(2,length(bothcam.mqn.inter.sd),3))])

#Z
bothcam.mqn.inter.sd.z <- as.data.frame(bothcam.mqn.inter.sd[c(seq(3,length(bothcam.mqn.inter.sd),3))])

#Combine the above into one dataframe
bothcam.mqn.inter.sd.axis <- cbind(bothcam.mqn.inter.sd.x, bothcam.mqn.inter.sd.y, bothcam.mqn.inter.sd.z)
colnames(bothcam.mqn.inter.sd.axis) <- c("X","Y","Z")

#Remove old files
rm(bothcam.mqn.inter.sd.x, bothcam.mqn.inter.sd.y, bothcam.mqn.inter.sd.z)

ggplot(melt(bothcam.mqn.inter.sd.axis), aes(x=variable, y = value, fill = variable))+geom_boxplot()+ggtitle("Average euclidean distance between replicates") + theme(legend.position = "none")+xlab("Replicate comparison")+ylab("Euclidean Distance")
```

## Euclidean distance between 3dMD and Vectra
### 35 ind
```{r}
#Empty matrix to store Euclidean distance values
bothcam.35ind.inter.euclid <- matrix(nrow = 35, ncol = 7160)

for(i in 1:35){
  #Pull out 3dMD coordinates and Vectra Coordinates
  tmp <- rbind(bothcam.35ind.aligned[i,], bothcam.35ind.aligned[i+35,])
  #Calculate and store Euclidean distance
   for(j in 1:length(coord.cols)){
     bothcam.35ind.inter.euclid[i,j] <- dist(as.matrix(tmp[,paste(coord.cols[j]):paste(coord.cols[j]+2)]))}
}
```

Plot euclidean distance per person
```{r}
rownames(bothcam.35ind.inter.euclid) <- paste0("P", 1:35)

p <- ggplot(melt(t(bothcam.35ind.inter.euclid)), aes(x=Var2,y=value))+geom_boxplot()+ggtitle("Camera error") + theme(legend.position = "none")+xlab("Individual")+ylab("Euclidean distance (mm)")+theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5), legend.position = "none")
ggsave(plot =  p, filename =  "Figures/CameraErrorPerParticipant.pdf", device = "pdf", width = 6, height = 4, units = "in")
p
```

Euclidean distance on face plot
```{r}
bothcam.35ind.inter.euclid.mean <- colMeans(bothcam.35ind.inter.euclid)

Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = bothcam.35ind.inter.euclid.mean, title = "Camera error \n Averaged across all participants")
```

### Mannequin
```{r}
bothcam.mqn.inter.euclid <- matrix(ncol = 7160)

for (j in 1:length(coord.cols)){
  #Calculate and store Euclidean distance
  bothcam.mqn.inter.euclid[j] <-  dist(as.matrix(bothcam.mqn.aligned[,paste(coord.cols[j]):paste(coord.cols[j]+2)]))}
```
Plot on face
```{r}
Plot1Face(vertices = RefScan_Vertices, facets = RefScan_Facets, colormap = bothcam.mqn.inter.euclid, title = "Mannequin camera error")
```

Plot
```{r}
ggplot(as.data.frame(t(bothcam.mqn.inter.euclid)), aes(x=V1))+geom_histogram()+ggtitle("Mannequin camera error") + theme(legend.position = "none")+xlab("Euclidean distance (mm)")+ylab("Number of quasi-landmarks")
```

# ANOVA
## Prepare the data
Put all the data in a single matrix
```{r}
#35 ind
all.35ind <- as.data.frame(rbind(md.35ind[1:21480], v.35ind[1:21480]))
colnames(all.35ind) <- paste0(c("x", "y", "z"), rep(1:7160, each=3))
rownames(all.35ind) <- c(paste0("MD.P", rep(1:35, each=3), c(".R1.M1", ".R2.M1", ".R3.M1")), paste0("MD.P", rep(1:35, each=3), c(".R1.M2", ".R2.M2", ".R3.M2")), paste0("MD.P", rep(1:35, each=3), c(".R1.M3", ".R2.M3", ".R3.M3")), paste0("V.P", rep(1:35, each=3), c(".R1.M1", ".R2.M1", ".R3.M1")), paste0("V.P", rep(1:35, each=3), c(".R1.M2", ".R2.M2", ".R3.M2")), paste0("V.P", rep(1:35, each=3), c(".R1.M3", ".R2.M3", ".R3.M3")))

#Mannequin
all.mqn <- as.data.frame(rbind(md.mqn[1:21480], v.mqn[1:21480]))
colnames(all.mqn) <- paste0(c("x", "y", "z"), rep(1:7160, each=3))
rownames(all.mqn) <- c(paste0("MD.Mqn", c(".R1.M1", ".R2.M1", ".R3.M1")), paste0("MD.Mqn", c(".R1.M2", ".R2.M2", ".R3.M2")), paste0("MD.Mqn", c(".R1.M3", ".R2.M3", ".R3.M3")), paste0("V.Mqn", c(".R1.M1", ".R2.M1", ".R3.M1")), paste0("V.Mqn", c(".R1.M2", ".R2.M2", ".R3.M2")), paste0("V.Mqn", c(".R1.M3", ".R2.M3", ".R3.M3")))
```

Prepare a covariate dataframe
```{r}
# 35 ind
all.35ind.cov <- as.data.frame(matrix(nrow = nrow(all.35ind), ncol = 4))
colnames(all.35ind.cov) <- c("Camera", "Individual", "Replicate", "Mapping")
all.35ind.cov$Camera <- c(rep("MD", times = 315), rep("V", times = 315))
all.35ind.cov$Individual <- c(unlist(strsplit(rownames(all.35ind), split = "\\."))[seq(2,2520,4)])
all.35ind.cov$Replicate <- c(unlist(strsplit(rownames(all.35ind), split = "\\."))[seq(3,2520,4)])
all.35ind.cov$Mapping <- c(unlist(strsplit(rownames(all.35ind), split = "\\."))[seq(4,2520,4)])

# Mannequin
all.mqn.cov <- as.data.frame(matrix(nrow = nrow(all.mqn), ncol= 4))
colnames(all.mqn.cov) <- c("Camera", "Individual", "Replicate", "Mapping")
all.mqn.cov$Camera <- c(rep("MD", times = 9), rep("V", times = 9))
all.mqn.cov$Individual <- "Mqn"
all.mqn.cov$Replicate <- c(paste0("R", rep(1:3, times = 6)))
all.mqn.cov$Mapping <- c(paste0("M", rep(1:3, each = 3, times = 2)))
```

GPA align the images
```{r}
#Convert the dataframe to geomorph format
all.35ind.geomorph <- arrayspecs(A=all.35ind, p = 7160, k = 3)
all.mqn.geomorph <- arrayspecs(A=all.mqn, p = 7160, k = 3)

#GPA align without scaling or reflecting
all.35ind.gpa <- ProcGPA(all.35ind.geomorph, scale = FALSE, CSinit = FALSE, silent = TRUE, reflection = FALSE)
all.mqn.gpa <- ProcGPA(all.mqn.geomorph, scale = FALSE, CSinit = FALSE, silent = TRUE, reflection = FALSE)

#Take out the aligned coordinates
all.35ind.aligned <- two.d.array(all.35ind.gpa$rotated)
all.mqn.aligned <- two.d.array(all.mqn.gpa$rotated)
```

Create geomorph data frame
```{r}
#35 ind
all.35ind.geomorph <- geomorph.data.frame(shape = all.35ind.aligned, 
Camera = all.35ind.cov$Camera, Individual = all.35ind.cov$Individual, Replicate = all.35ind.cov$Replicate, Mapping = all.35ind.cov$Mapping)

#Mannequin
all.mqn.geomorph <- geomorph.data.frame(shape = all.mqn.aligned, 
Camera = all.mqn.cov$Camera, Individual = all.mqn.cov$Individual, Replicate = all.mqn.cov$Replicate, Mapping = all.mqn.cov$Mapping)
```

Convert to mat send to Alejandra to run the Anova
```{r}
#Making 3d dataframe
all.35ind.coords <- arrayspecs(A = all.35ind.aligned, p = 7160, k = 3)
all.mqn.coords <- arrayspecs(A = all.mqn.aligned, p = 7160, k = 3)
```

```{r}
writeMat("All.35ind.7160LM.mat", coords = all.35ind.coords, covar = all.35ind.cov)
writeMat("All.Mqn.7160LM.mat", coords = all.mqn.coords, covar = all.mqn.cov)
```

## Run ANOVA - not sure if this is right
```{r}
all.35ind.anova <- procD.lm(shape ~ Individual + Replicate + Camera + Mapping, iter = 1000, RRPP = TRUE, print.progress = FALSE, data = all.35ind.geomorph)

all.mqn.anova <- procD.lm(shape ~ Replicate + Camera + Mapping, RRPP = TRUE, iter = 1000, print.progress = FALSE, data = all.mqn.geomorph)
```
